package Recursive_Tree_Graph;
import java.util.*;


// --- Main 클래스 설명 시작 ---
// 이 클래스 안에 프로그램의 모든 기능이 구현되어 있습니다.
class Main8 {
    int answer=0; // (현재 코드에서는 사용되지 않지만) 보통 최종 결과를 저장하는 변수입니다.

    // 'dis' 배열은 현재 숫자에서 다음 숫자로 이동할 수 있는 '거리' (변화량)를 정의합니다.
    // 즉, +1, -1, +5 세 가지 방법으로 이동할 수 있다는 뜻입니다.
    int[] dis={1, -1, 5};

    // 'ch' 배열은 '체크(check) 배열'입니다.
    // 각 숫자를 방문했는지 안 했는지 기록하는 용도입니다.
    // 'ch[i] = 0'이면 i번 숫자를 아직 방문하지 않음, 'ch[i] = 1'이면 i번 숫자를 이미 방문했음을 의미합니다.
    // 문제에서 숫자의 범위가 1부터 10000까지이므로, 배열 크기를 10001로 설정합니다. (인덱스 0은 사용 안 함)
    int[] ch;

    // 'Q'는 '큐(Queue)'입니다. BFS 탐색을 위한 필수적인 자료구조입니다.
    // 'LinkedList'는 Queue 인터페이스를 구현하는 클래스 중 하나로, 큐처럼 사용할 수 있습니다.
    // 여기에 다음에 탐색할 숫자들을 차례대로 넣고 뺄 것입니다.
    Queue<Integer> Q = new LinkedList<>();

    /**
     * --- BFS 메서드 설명 시작 ---
     * 이 메서드는 출발 숫자 's'에서 도착 숫자 'e'까지 도달하는 최소 이동 횟수를 찾아 반환합니다.
     * @param s 시작 숫자 (Start)
     * @param e 목표 숫자 (End)
     * @return s에서 e까지의 최소 이동 횟수 (도달할 수 없는 경우 0)
     */
    public int BFS(int s, int e){
        // BFS를 시작할 때마다 'ch' 배열을 새로 초기화합니다.
        // 모든 숫자를 '방문하지 않은' 상태(0)로 만듭니다.
        ch=new int[10001];

        // 출발 숫자 's'는 이제 막 방문을 시작했으므로, '방문했음(1)'으로 표시합니다.
        ch[s]=1;

        // 큐에 출발 숫자 's'를 넣습니다. 이제 's'부터 탐색을 시작합니다.
        Q.offer(s);

        // 'L'은 '레벨(Level)'을 나타냅니다.
        // BFS에서는 레벨이 곧 '이동 횟수' (깊이)가 됩니다.
        // 시작점은 0번 이동한 상태이므로 0으로 초기화합니다.
        int L=0;

        // --- while 루프 설명 시작 ---
        // 'while(!Q.isEmpty())' : 큐가 비어있지 않은 동안 계속 반복합니다.
        // 즉, '더 이상 탐색할 숫자가 남아있지 않을 때까지' 계속 탐색을 진행한다는 뜻입니다.
        while(!Q.isEmpty()){
            // 'len'은 현재 큐에 들어있는 노드의 개수입니다.
            // 이 개수는 현재 'L' 레벨에 있는 모든 숫자들의 개수와 같습니다.
            // 이 숫자를 통해 현재 레벨의 모든 숫자들을 한 번에 처리할 수 있습니다.
            int len=Q.size();

            // --- for 루프 설명 시작 ---
            // 'for(int i=0; i<len; i++)' : 현재 레벨에 있는 모든 숫자들을 하나씩 꺼내서 탐색합니다.
            // 'i'는 0부터 'len-1'까지 증가하면서 반복됩니다.
            for(int i=0; i<len; i++){
                // 'x = Q.poll()' : 큐의 맨 앞에 있는 숫자(노드)를 하나 꺼냅니다. (대기열의 맨 앞 사람을 불러냄)
                // 이 'x'가 현재 우리가 탐색하고 있는 숫자입니다.
                int x = Q.poll();

                // --- 내부 for 루프 설명 시작 ---
                // 'for(int j=0; j<3; j++)' : 현재 숫자 'x'에서 이동할 수 있는 세 가지 방법 (+1, -1, +5)을 모두 시도합니다.
                // 'j'는 0, 1, 2 값을 가집니다.
                for(int j=0; j<3; j++){
                    // 'nx = x + dis[j]' : 'nx'는 현재 숫자 'x'에서 'dis[j]'만큼 이동했을 때의 새로운 숫자입니다.
                    // 예: x=5일 때, nx는 5+1=6, 5-1=4, 5+5=10이 될 수 있습니다.
                    int nx=x+dis[j];

                    // --- 도착점 확인 ---
                    // 'if(nx==e)' : 만약 새로운 숫자 'nx'가 우리가 찾던 도착점 'e'와 같다면,
                    if(nx==e){
                        // 도착점에 도달했으므로, 현재까지의 이동 횟수(L)에 1을 더한 값(즉, 바로 다음 이동으로 도착)을 반환합니다.
                        // BFS는 최단 거리를 보장하므로, 여기서 찾은 경로가 가장 짧은 경로입니다.
                        return L+1;
                    }

                    // --- 유효성 및 방문 여부 확인 ---
                    // 'if(nx>=1 && nx<=10000 && ch[nx]==0)' :
                    // 1. 'nx>=1 && nx<=10000' : 새로운 숫자 'nx'가 문제에서 허용하는 범위(1부터 10000) 안에 있는지 확인합니다.
                    // 2. 'ch[nx]==0' : 새로운 숫자 'nx'를 아직 방문하지 않았는지 확인합니다. (이미 방문한 곳은 다시 갈 필요 없음)
                    if(nx>=1 && nx<=10000 && ch[nx]==0){
                        // 위의 두 조건을 모두 만족하면, 새로운 숫자 'nx'를 유효한 다음 탐색 대상으로 간주합니다.
                        ch[nx]=1;    // 'nx'를 방문했음(1)으로 표시합니다.
                        Q.offer(nx); // 'nx'를 큐에 추가합니다. (다음 레벨에서 탐색할 숫자 대기열에 넣어둠)
                    }
                }
                // --- 내부 for 루프 설명 끝 ---
            }
            // --- for 루프 설명 끝 ---

            // 현재 레벨(L)에 있는 모든 숫자들을 다 탐색하고, 다음 레벨의 숫자들을 큐에 모두 넣었습니다.
            // 이제 다음 레벨로 넘어갈 차례이므로, 이동 횟수(L)를 1 증가시킵니다.
            L++;
        }
        // --- while 루프 설명 끝 ---

        // 큐가 비어버렸는데도 도착점 'e'에 도달하지 못했다면,
        // 이는 's'에서 'e'까지 도달하는 경로가 없다는 의미입니다.
        // 이 경우 0을 반환합니다.
        return 0;
    }
    // --- BFS 메서드 설명 끝 ---

    // --- main 메서드 설명 시작 ---
    // 이 메서드는 자바 프로그램이 시작될 때 가장 먼저 실행되는 부분입니다.
    public static void main(String[] args){
        // 'Main' 클래스의 객체를 하나 만듭니다. 이 객체를 통해 BFS 메서드를 호출할 거예요.
        Main8 T = new Main8();

        // 'Scanner'를 사용하여 사용자로부터 입력을 받습니다.
        Scanner kb = new Scanner(System.in);

        // 사용자로부터 출발 숫자 's'를 입력받습니다.
        int s=kb.nextInt();
        // 사용자로부터 도착 숫자 'e'를 입력받습니다.
        int e=kb.nextInt();

        // T 객체의 BFS 메서드를 호출하여 's'에서 'e'까지의 최단 이동 횟수를 계산하고,
        // 그 결과를 화면에 출력합니다.
        System.out.println(T.BFS(s, e));
    }
}
// --- Main 클래스 설명 끝 ---